# 画布区

画布区用来渲染组件，组件又是通过scheme来定义的。当我们通过拖拽组件到画布区时，实际上是将一个组件的scheme添加到画布区的scheme中。
我们先来看一个输入组件的scheme：

```js
  const inputSchema = {
      __config__: {
        label: '单行文本',
        labelWidth: null,
        showLabel: true,
        changeTag: true,
        tag: 'el-input',
        tagIcon: 'input',
        defaultValue: undefined,
        required: true,
        layout: 'colFormItem',
        span: 24,
        document: 'https://element.eleme.cn/#/zh-CN/component/input',
        // 正则校验规则
        regList: [{
          pattern: '/^1(3|4|5|7|8|9)\\d{9}$/',
          message: '手机号格式错误'
        }]
      },
      // 组件的插槽属性
      __slot__: {
        prepend: '',
        append: ''
      },
      __vModel__: 'mobile',
      placeholder: '请输入手机号',
      style: { width: '100%' },
      clearable: true,
      'prefix-icon': 'el-icon-mobile',
      'suffix-icon': '',
      maxlength: 11,
      'show-word-limit': true,
      readonly: false,
      disabled: false
}
```
关于scheme的解释，我们已经在之前的文章中介绍过了，这里不再赘述。
那么我们如何将这个scheme渲染到画布区呢？我们可以通过v-for指令来遍历scheme，然后根据scheme的tag属性来渲染不同的组件。

```js
export default {
	render(h) {
			return h(this.conf.__config__.tag, dataObject, children)
    }
}
```
通过如上的代码，我们就可以将一个组件渲染到画布区了。

但我们只是将组件渲染到画布区了，仍然有一些问题需要解决：
+ 如何将组件的props透传给element-ui组件
+ 如何渲染插槽内容，例如prepend和append
+ 如何校验表单数据

## 将组件的props透传给element-ui组件
在调用render函数时，我们的第二个参数是一个数据对象，这我们可以通过这个参数将scheme中的属性透传给element-ui组件。
我们将属性通过attrs属性传递给element-ui组件，如下：
```js
export default {
    render(h) {
        const dataObject = {
            attrs: {
                maxlength: 11,
                placeholder: "请输入手机号"
            },
        }
        return h(this.conf.__config__.tag, dataObject, children)
    }
}
```
通过attrs我们的大部分属性都可以透传给element-ui组件了，其他的例如style，class等，这些属性我们可以通过数据对象的`style`和`class`属性传递给element-ui组件。

还有一个很关键的属性我们还没有透传，那就是v-model，众所周知，`v-model`是个语法糖，那么我们可以传递`value`,并且通过`on`属性来传递事件，如下：
```js
export default {
    render(h) {
        const dataObject = {
            attrs: {
                maxlength: 11,
                placeholder: "请输入手机号"
            },
          props: {
                value: this.__config__.defaultValue
          },
          on: {
            input: (val) => {
                this.$set(config, 'defaultValue', event)
            }
          }
        }
        return h(this.conf.__config__.tag, dataObject, children)
    }
}
```
我们通过value属性传递了v-model的值，通过on属性传递了input事件，在input事件中，我们修改`defaultValue`,这样我们就实现了v-model与schema的联通响应。

## 渲染插槽内容
在我们使用el-input组件时，可能会用到prepend和append插槽，在schema中我们的插槽表示如下：
```schema
 // 组件的插槽属性
      __slot__: {
        prepend: 'hello',
        append: 'world'
      },
```
显然插槽最终要通过第三个参数children传递给element-ui组件，我们可以通过如下代码实现：
```js
// 核心代码
const children = []
if (this.conf.__slot__.prepend) {
    children.push(h('template', { slot: 'prepend' }, this.conf.__slot__.prepend))
}
if (this.conf.__slot__.append) {
    children.push(h('template', { slot: 'append' }, this.conf.__slot__.append))
}
h(this.conf.__config__.tag, dataObject, children)
```
在上面的代码中我们将slot属性通过`h`函数处理为虚拟节点，并插入到`children`中，最后通过`h`函数渲染到element-ui组件中。

## 校验表单数据
在传统开发过程中，表单的校验离不开几个步骤：
+ 校验规则的定义
+ `<el-form ref="formRef" :model="formData" :rules="rules">`使用
+ `<el-form-item prop="xxx">`的使用

### 校验规则的定义
在我们的schema中，我们定义了一个`regList`数组，这个数组中的每一项都相当于我们`rules`中的每个属性下的校验规则，最后我们在渲染的时候会将这个`regList`数组转换为`rules`中的对象，这里后续我们再展开分析。
### 插入<el-form>
在画布区渲染组件时，我们需要给组件最外层套一个`<el-form>`组件。
```vue
<el-form></el-form>>
```
`form`组件也有很多属性，属性的传递我们这里也不过多赘述
### 插入<el-form-item>
在schema中，我们定义了一个`layout`属性，这个属性表示我们的组件是行内布局还是列布局，如果是列布局，我们需要给组件套一个`<el-form-item>`组件
```vue
<el-form>
  <el-form-item label={config.showLabel ? config.label : ''} required={config.required} prop={config.__vModel__} label-width={labelWidth} rules={config.regList}>
    <render></render> // 渲染elementUI组件
  </el-form-item>
</el-form>>
```
在`<el-form-item>`中，我们需要传递一些属性，例如label，required，prop，label-width，rules等，这些属性我们都可以从schema中的`__config__`获取到，这里不再赘述。

## 番外
画布区的渲染我们已经实现了，但是如果使用过低代码的同学应该知道，渲染区域也是需要可以拖拽的，这个功能我们同样通过`vuedraggable`来实现，代码如下：
```vue
<draggable class="drawing-board" :list="drawingList" :animation="300" group="componentsGroup">
  <DraggableItem
      v-for="(item, index) in drawingList"
      :key="item.renderKey"
      :currentItem="item"
      :index="index"
      :drawingList="drawingList"
  ></DraggableItem>
</draggable>
```
## 总结
通过上面的分析，我们实现了画布区schema的渲染，其他的组件的渲染逻辑类似，下回我们继续分享组件编辑区域的实现。
